// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.5
//   protoc               v5.28.3
// source: command.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  ClientReadableStream,
  type ClientUnaryCall,
  handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "command";

export enum FlightMode {
  STARTUP = 0,
  STANDBY = 1,
  ASCENT = 2,
  DROGUE_DEPLOYED = 3,
  MAIN_DEPLOYED = 4,
  FAULT = 5,
  UNRECOGNIZED = -1,
}

export function flightModeFromJSON(object: any): FlightMode {
  switch (object) {
    case 0:
    case "STARTUP":
      return FlightMode.STARTUP;
    case 1:
    case "STANDBY":
      return FlightMode.STANDBY;
    case 2:
    case "ASCENT":
      return FlightMode.ASCENT;
    case 3:
    case "DROGUE_DEPLOYED":
      return FlightMode.DROGUE_DEPLOYED;
    case 4:
    case "MAIN_DEPLOYED":
      return FlightMode.MAIN_DEPLOYED;
    case 5:
    case "FAULT":
      return FlightMode.FAULT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FlightMode.UNRECOGNIZED;
  }
}

export function flightModeToJSON(object: FlightMode): string {
  switch (object) {
    case FlightMode.STARTUP:
      return "STARTUP";
    case FlightMode.STANDBY:
      return "STANDBY";
    case FlightMode.ASCENT:
      return "ASCENT";
    case FlightMode.DROGUE_DEPLOYED:
      return "DROGUE_DEPLOYED";
    case FlightMode.MAIN_DEPLOYED:
      return "MAIN_DEPLOYED";
    case FlightMode.FAULT:
      return "FAULT";
    case FlightMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The telemetry message
 * TODO(Zach) add parameters for commanding
 */
export interface Command {
  sv1Open?: boolean | undefined;
  bv1Open?: boolean | undefined;
  bv1Off?: boolean | undefined;
  qdRetract?: boolean | undefined;
  ignite?: boolean | undefined;
  sv2Close?: boolean | undefined;
  mavOpen?: boolean | undefined;
  fire?: boolean | undefined;
}

/**
 * The response message containing an ack
 * TODO(Zach) add relevant reply values?
 */
export interface CommandReply {
}

/** The telemetry request message */
export interface TelemetryRequest {
}

export interface Events {
  keyArmed: boolean;
  altitudeArmed: boolean;
  altimeterInitFailed: boolean;
  altimeterReadingFailed: boolean;
  altimeterWasTurnedOff: boolean;
  gpsInitFailed: boolean;
  gpsReadingFailed: boolean;
  gpsWasTurnedOff: boolean;
  imuInitFailed: boolean;
  imuReadingFailed: boolean;
  imuWasTurnedOff: boolean;
  accelerometerInitFailed: boolean;
  accelerometerReadingFailed: boolean;
  accelerometerWasTurnedOff: boolean;
  thermometerInitFailed: boolean;
  thermometerReadingFailed: boolean;
  thermometerWasTurnedOff: boolean;
  sdInitFailed: boolean;
  sdWriteFailed: boolean;
  rfmInitFailed: boolean;
  rfmTransmitFailed: boolean;
}

export interface RocketMetadata {
  altArmed: boolean;
  altValid: boolean;
  gpsValid: boolean;
  imuValid: boolean;
  accValid: boolean;
  thermValid: boolean;
  voltageValid: boolean;
  adcValid: boolean;
  framValid: boolean;
  sdValid: boolean;
  gpsMsgValid: boolean;
  mavState: boolean;
  svState: boolean;
  flightMode: FlightMode;
}

export interface GPSTelemetry {
  latitude: number;
  longitude: number;
  numSatellites: number;
  utcTime: number;
}

export interface AccelerometerTelemetry {
  accelX: number;
  accelY: number;
  accelZ: number;
}

export interface IMUTelemetry {
  gyroX: number;
  gyroY: number;
  gyroZ: number;
  accelX: number;
  accelY: number;
  accelZ: number;
  oriX: number;
  oriY: number;
  oriZ: number;
  gravX: number;
  gravY: number;
  gravZ: number;
}

export interface RocketLoRaTelemetry {
  metadata: RocketMetadata | undefined;
  msSinceBoot: number;
  events: Events | undefined;
  altitude: number;
  gpsTelem: GPSTelemetry | undefined;
  imuTelem: IMUTelemetry | undefined;
  accelTelem: AccelerometerTelemetry | undefined;
  temp: number;
  voltage: number;
  pt3: number;
  pt4: number;
  blimsState: number;
}

export interface RocketUmbTelemetry {
  metadata: RocketMetadata | undefined;
  msSinceBoot: number;
  events: Events | undefined;
  radioState: boolean;
  transmitState: boolean;
  voltage: number;
  pt3: number;
  pt4: number;
  rtdTemp: number;
}

export interface RocketTelemetry {
  loraTelem?: RocketLoRaTelemetry | undefined;
  umbTelem?: RocketUmbTelemetry | undefined;
}

/** The telemetry message */
export interface FillStationTelemetry {
  timestamp: number;
  pt1: number;
  pt2: number;
  lc1: number;
  sv1Cont: number;
  ign1Cont: number;
  ign2Cont: number;
}

function createBaseCommand(): Command {
  return {
    sv1Open: undefined,
    bv1Open: undefined,
    bv1Off: undefined,
    qdRetract: undefined,
    ignite: undefined,
    sv2Close: undefined,
    mavOpen: undefined,
    fire: undefined,
  };
}

export const Command: MessageFns<Command> = {
  encode(message: Command, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sv1Open !== undefined) {
      writer.uint32(8).bool(message.sv1Open);
    }
    if (message.bv1Open !== undefined) {
      writer.uint32(16).bool(message.bv1Open);
    }
    if (message.bv1Off !== undefined) {
      writer.uint32(24).bool(message.bv1Off);
    }
    if (message.qdRetract !== undefined) {
      writer.uint32(32).bool(message.qdRetract);
    }
    if (message.ignite !== undefined) {
      writer.uint32(40).bool(message.ignite);
    }
    if (message.sv2Close !== undefined) {
      writer.uint32(48).bool(message.sv2Close);
    }
    if (message.mavOpen !== undefined) {
      writer.uint32(56).bool(message.mavOpen);
    }
    if (message.fire !== undefined) {
      writer.uint32(64).bool(message.fire);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Command {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sv1Open = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.bv1Open = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.bv1Off = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.qdRetract = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.ignite = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.sv2Close = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.mavOpen = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.fire = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Command {
    return {
      sv1Open: isSet(object.sv1Open) ? globalThis.Boolean(object.sv1Open) : undefined,
      bv1Open: isSet(object.bv1Open) ? globalThis.Boolean(object.bv1Open) : undefined,
      bv1Off: isSet(object.bv1Off) ? globalThis.Boolean(object.bv1Off) : undefined,
      qdRetract: isSet(object.qdRetract) ? globalThis.Boolean(object.qdRetract) : undefined,
      ignite: isSet(object.ignite) ? globalThis.Boolean(object.ignite) : undefined,
      sv2Close: isSet(object.sv2Close) ? globalThis.Boolean(object.sv2Close) : undefined,
      mavOpen: isSet(object.mavOpen) ? globalThis.Boolean(object.mavOpen) : undefined,
      fire: isSet(object.fire) ? globalThis.Boolean(object.fire) : undefined,
    };
  },

  toJSON(message: Command): unknown {
    const obj: any = {};
    if (message.sv1Open !== undefined) {
      obj.sv1Open = message.sv1Open;
    }
    if (message.bv1Open !== undefined) {
      obj.bv1Open = message.bv1Open;
    }
    if (message.bv1Off !== undefined) {
      obj.bv1Off = message.bv1Off;
    }
    if (message.qdRetract !== undefined) {
      obj.qdRetract = message.qdRetract;
    }
    if (message.ignite !== undefined) {
      obj.ignite = message.ignite;
    }
    if (message.sv2Close !== undefined) {
      obj.sv2Close = message.sv2Close;
    }
    if (message.mavOpen !== undefined) {
      obj.mavOpen = message.mavOpen;
    }
    if (message.fire !== undefined) {
      obj.fire = message.fire;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Command>, I>>(base?: I): Command {
    return Command.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Command>, I>>(object: I): Command {
    const message = createBaseCommand();
    message.sv1Open = object.sv1Open ?? undefined;
    message.bv1Open = object.bv1Open ?? undefined;
    message.bv1Off = object.bv1Off ?? undefined;
    message.qdRetract = object.qdRetract ?? undefined;
    message.ignite = object.ignite ?? undefined;
    message.sv2Close = object.sv2Close ?? undefined;
    message.mavOpen = object.mavOpen ?? undefined;
    message.fire = object.fire ?? undefined;
    return message;
  },
};

function createBaseCommandReply(): CommandReply {
  return {};
}

export const CommandReply: MessageFns<CommandReply> = {
  encode(_: CommandReply, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommandReply {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommandReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CommandReply {
    return {};
  },

  toJSON(_: CommandReply): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<CommandReply>, I>>(base?: I): CommandReply {
    return CommandReply.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommandReply>, I>>(_: I): CommandReply {
    const message = createBaseCommandReply();
    return message;
  },
};

function createBaseTelemetryRequest(): TelemetryRequest {
  return {};
}

export const TelemetryRequest: MessageFns<TelemetryRequest> = {
  encode(_: TelemetryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TelemetryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTelemetryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): TelemetryRequest {
    return {};
  },

  toJSON(_: TelemetryRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<TelemetryRequest>, I>>(base?: I): TelemetryRequest {
    return TelemetryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TelemetryRequest>, I>>(_: I): TelemetryRequest {
    const message = createBaseTelemetryRequest();
    return message;
  },
};

function createBaseEvents(): Events {
  return {
    keyArmed: false,
    altitudeArmed: false,
    altimeterInitFailed: false,
    altimeterReadingFailed: false,
    altimeterWasTurnedOff: false,
    gpsInitFailed: false,
    gpsReadingFailed: false,
    gpsWasTurnedOff: false,
    imuInitFailed: false,
    imuReadingFailed: false,
    imuWasTurnedOff: false,
    accelerometerInitFailed: false,
    accelerometerReadingFailed: false,
    accelerometerWasTurnedOff: false,
    thermometerInitFailed: false,
    thermometerReadingFailed: false,
    thermometerWasTurnedOff: false,
    sdInitFailed: false,
    sdWriteFailed: false,
    rfmInitFailed: false,
    rfmTransmitFailed: false,
  };
}

export const Events: MessageFns<Events> = {
  encode(message: Events, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyArmed !== false) {
      writer.uint32(8).bool(message.keyArmed);
    }
    if (message.altitudeArmed !== false) {
      writer.uint32(16).bool(message.altitudeArmed);
    }
    if (message.altimeterInitFailed !== false) {
      writer.uint32(24).bool(message.altimeterInitFailed);
    }
    if (message.altimeterReadingFailed !== false) {
      writer.uint32(32).bool(message.altimeterReadingFailed);
    }
    if (message.altimeterWasTurnedOff !== false) {
      writer.uint32(40).bool(message.altimeterWasTurnedOff);
    }
    if (message.gpsInitFailed !== false) {
      writer.uint32(48).bool(message.gpsInitFailed);
    }
    if (message.gpsReadingFailed !== false) {
      writer.uint32(56).bool(message.gpsReadingFailed);
    }
    if (message.gpsWasTurnedOff !== false) {
      writer.uint32(64).bool(message.gpsWasTurnedOff);
    }
    if (message.imuInitFailed !== false) {
      writer.uint32(72).bool(message.imuInitFailed);
    }
    if (message.imuReadingFailed !== false) {
      writer.uint32(80).bool(message.imuReadingFailed);
    }
    if (message.imuWasTurnedOff !== false) {
      writer.uint32(88).bool(message.imuWasTurnedOff);
    }
    if (message.accelerometerInitFailed !== false) {
      writer.uint32(96).bool(message.accelerometerInitFailed);
    }
    if (message.accelerometerReadingFailed !== false) {
      writer.uint32(104).bool(message.accelerometerReadingFailed);
    }
    if (message.accelerometerWasTurnedOff !== false) {
      writer.uint32(112).bool(message.accelerometerWasTurnedOff);
    }
    if (message.thermometerInitFailed !== false) {
      writer.uint32(120).bool(message.thermometerInitFailed);
    }
    if (message.thermometerReadingFailed !== false) {
      writer.uint32(128).bool(message.thermometerReadingFailed);
    }
    if (message.thermometerWasTurnedOff !== false) {
      writer.uint32(136).bool(message.thermometerWasTurnedOff);
    }
    if (message.sdInitFailed !== false) {
      writer.uint32(144).bool(message.sdInitFailed);
    }
    if (message.sdWriteFailed !== false) {
      writer.uint32(152).bool(message.sdWriteFailed);
    }
    if (message.rfmInitFailed !== false) {
      writer.uint32(160).bool(message.rfmInitFailed);
    }
    if (message.rfmTransmitFailed !== false) {
      writer.uint32(168).bool(message.rfmTransmitFailed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Events {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvents();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.keyArmed = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.altitudeArmed = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.altimeterInitFailed = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.altimeterReadingFailed = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.altimeterWasTurnedOff = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.gpsInitFailed = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.gpsReadingFailed = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.gpsWasTurnedOff = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.imuInitFailed = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.imuReadingFailed = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.imuWasTurnedOff = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.accelerometerInitFailed = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.accelerometerReadingFailed = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.accelerometerWasTurnedOff = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.thermometerInitFailed = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.thermometerReadingFailed = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.thermometerWasTurnedOff = reader.bool();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.sdInitFailed = reader.bool();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.sdWriteFailed = reader.bool();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.rfmInitFailed = reader.bool();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.rfmTransmitFailed = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Events {
    return {
      keyArmed: isSet(object.keyArmed) ? globalThis.Boolean(object.keyArmed) : false,
      altitudeArmed: isSet(object.altitudeArmed) ? globalThis.Boolean(object.altitudeArmed) : false,
      altimeterInitFailed: isSet(object.altimeterInitFailed) ? globalThis.Boolean(object.altimeterInitFailed) : false,
      altimeterReadingFailed: isSet(object.altimeterReadingFailed)
        ? globalThis.Boolean(object.altimeterReadingFailed)
        : false,
      altimeterWasTurnedOff: isSet(object.altimeterWasTurnedOff)
        ? globalThis.Boolean(object.altimeterWasTurnedOff)
        : false,
      gpsInitFailed: isSet(object.gpsInitFailed) ? globalThis.Boolean(object.gpsInitFailed) : false,
      gpsReadingFailed: isSet(object.gpsReadingFailed) ? globalThis.Boolean(object.gpsReadingFailed) : false,
      gpsWasTurnedOff: isSet(object.gpsWasTurnedOff) ? globalThis.Boolean(object.gpsWasTurnedOff) : false,
      imuInitFailed: isSet(object.imuInitFailed) ? globalThis.Boolean(object.imuInitFailed) : false,
      imuReadingFailed: isSet(object.imuReadingFailed) ? globalThis.Boolean(object.imuReadingFailed) : false,
      imuWasTurnedOff: isSet(object.imuWasTurnedOff) ? globalThis.Boolean(object.imuWasTurnedOff) : false,
      accelerometerInitFailed: isSet(object.accelerometerInitFailed)
        ? globalThis.Boolean(object.accelerometerInitFailed)
        : false,
      accelerometerReadingFailed: isSet(object.accelerometerReadingFailed)
        ? globalThis.Boolean(object.accelerometerReadingFailed)
        : false,
      accelerometerWasTurnedOff: isSet(object.accelerometerWasTurnedOff)
        ? globalThis.Boolean(object.accelerometerWasTurnedOff)
        : false,
      thermometerInitFailed: isSet(object.thermometerInitFailed)
        ? globalThis.Boolean(object.thermometerInitFailed)
        : false,
      thermometerReadingFailed: isSet(object.thermometerReadingFailed)
        ? globalThis.Boolean(object.thermometerReadingFailed)
        : false,
      thermometerWasTurnedOff: isSet(object.thermometerWasTurnedOff)
        ? globalThis.Boolean(object.thermometerWasTurnedOff)
        : false,
      sdInitFailed: isSet(object.sdInitFailed) ? globalThis.Boolean(object.sdInitFailed) : false,
      sdWriteFailed: isSet(object.sdWriteFailed) ? globalThis.Boolean(object.sdWriteFailed) : false,
      rfmInitFailed: isSet(object.rfmInitFailed) ? globalThis.Boolean(object.rfmInitFailed) : false,
      rfmTransmitFailed: isSet(object.rfmTransmitFailed) ? globalThis.Boolean(object.rfmTransmitFailed) : false,
    };
  },

  toJSON(message: Events): unknown {
    const obj: any = {};
    if (message.keyArmed !== false) {
      obj.keyArmed = message.keyArmed;
    }
    if (message.altitudeArmed !== false) {
      obj.altitudeArmed = message.altitudeArmed;
    }
    if (message.altimeterInitFailed !== false) {
      obj.altimeterInitFailed = message.altimeterInitFailed;
    }
    if (message.altimeterReadingFailed !== false) {
      obj.altimeterReadingFailed = message.altimeterReadingFailed;
    }
    if (message.altimeterWasTurnedOff !== false) {
      obj.altimeterWasTurnedOff = message.altimeterWasTurnedOff;
    }
    if (message.gpsInitFailed !== false) {
      obj.gpsInitFailed = message.gpsInitFailed;
    }
    if (message.gpsReadingFailed !== false) {
      obj.gpsReadingFailed = message.gpsReadingFailed;
    }
    if (message.gpsWasTurnedOff !== false) {
      obj.gpsWasTurnedOff = message.gpsWasTurnedOff;
    }
    if (message.imuInitFailed !== false) {
      obj.imuInitFailed = message.imuInitFailed;
    }
    if (message.imuReadingFailed !== false) {
      obj.imuReadingFailed = message.imuReadingFailed;
    }
    if (message.imuWasTurnedOff !== false) {
      obj.imuWasTurnedOff = message.imuWasTurnedOff;
    }
    if (message.accelerometerInitFailed !== false) {
      obj.accelerometerInitFailed = message.accelerometerInitFailed;
    }
    if (message.accelerometerReadingFailed !== false) {
      obj.accelerometerReadingFailed = message.accelerometerReadingFailed;
    }
    if (message.accelerometerWasTurnedOff !== false) {
      obj.accelerometerWasTurnedOff = message.accelerometerWasTurnedOff;
    }
    if (message.thermometerInitFailed !== false) {
      obj.thermometerInitFailed = message.thermometerInitFailed;
    }
    if (message.thermometerReadingFailed !== false) {
      obj.thermometerReadingFailed = message.thermometerReadingFailed;
    }
    if (message.thermometerWasTurnedOff !== false) {
      obj.thermometerWasTurnedOff = message.thermometerWasTurnedOff;
    }
    if (message.sdInitFailed !== false) {
      obj.sdInitFailed = message.sdInitFailed;
    }
    if (message.sdWriteFailed !== false) {
      obj.sdWriteFailed = message.sdWriteFailed;
    }
    if (message.rfmInitFailed !== false) {
      obj.rfmInitFailed = message.rfmInitFailed;
    }
    if (message.rfmTransmitFailed !== false) {
      obj.rfmTransmitFailed = message.rfmTransmitFailed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Events>, I>>(base?: I): Events {
    return Events.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Events>, I>>(object: I): Events {
    const message = createBaseEvents();
    message.keyArmed = object.keyArmed ?? false;
    message.altitudeArmed = object.altitudeArmed ?? false;
    message.altimeterInitFailed = object.altimeterInitFailed ?? false;
    message.altimeterReadingFailed = object.altimeterReadingFailed ?? false;
    message.altimeterWasTurnedOff = object.altimeterWasTurnedOff ?? false;
    message.gpsInitFailed = object.gpsInitFailed ?? false;
    message.gpsReadingFailed = object.gpsReadingFailed ?? false;
    message.gpsWasTurnedOff = object.gpsWasTurnedOff ?? false;
    message.imuInitFailed = object.imuInitFailed ?? false;
    message.imuReadingFailed = object.imuReadingFailed ?? false;
    message.imuWasTurnedOff = object.imuWasTurnedOff ?? false;
    message.accelerometerInitFailed = object.accelerometerInitFailed ?? false;
    message.accelerometerReadingFailed = object.accelerometerReadingFailed ?? false;
    message.accelerometerWasTurnedOff = object.accelerometerWasTurnedOff ?? false;
    message.thermometerInitFailed = object.thermometerInitFailed ?? false;
    message.thermometerReadingFailed = object.thermometerReadingFailed ?? false;
    message.thermometerWasTurnedOff = object.thermometerWasTurnedOff ?? false;
    message.sdInitFailed = object.sdInitFailed ?? false;
    message.sdWriteFailed = object.sdWriteFailed ?? false;
    message.rfmInitFailed = object.rfmInitFailed ?? false;
    message.rfmTransmitFailed = object.rfmTransmitFailed ?? false;
    return message;
  },
};

function createBaseRocketMetadata(): RocketMetadata {
  return {
    altArmed: false,
    altValid: false,
    gpsValid: false,
    imuValid: false,
    accValid: false,
    thermValid: false,
    voltageValid: false,
    adcValid: false,
    framValid: false,
    sdValid: false,
    gpsMsgValid: false,
    mavState: false,
    svState: false,
    flightMode: 0,
  };
}

export const RocketMetadata: MessageFns<RocketMetadata> = {
  encode(message: RocketMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.altArmed !== false) {
      writer.uint32(8).bool(message.altArmed);
    }
    if (message.altValid !== false) {
      writer.uint32(16).bool(message.altValid);
    }
    if (message.gpsValid !== false) {
      writer.uint32(24).bool(message.gpsValid);
    }
    if (message.imuValid !== false) {
      writer.uint32(32).bool(message.imuValid);
    }
    if (message.accValid !== false) {
      writer.uint32(40).bool(message.accValid);
    }
    if (message.thermValid !== false) {
      writer.uint32(48).bool(message.thermValid);
    }
    if (message.voltageValid !== false) {
      writer.uint32(56).bool(message.voltageValid);
    }
    if (message.adcValid !== false) {
      writer.uint32(64).bool(message.adcValid);
    }
    if (message.framValid !== false) {
      writer.uint32(72).bool(message.framValid);
    }
    if (message.sdValid !== false) {
      writer.uint32(80).bool(message.sdValid);
    }
    if (message.gpsMsgValid !== false) {
      writer.uint32(88).bool(message.gpsMsgValid);
    }
    if (message.mavState !== false) {
      writer.uint32(96).bool(message.mavState);
    }
    if (message.svState !== false) {
      writer.uint32(104).bool(message.svState);
    }
    if (message.flightMode !== 0) {
      writer.uint32(112).int32(message.flightMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RocketMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRocketMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.altArmed = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.altValid = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.gpsValid = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.imuValid = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.accValid = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.thermValid = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.voltageValid = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.adcValid = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.framValid = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.sdValid = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.gpsMsgValid = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.mavState = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.svState = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.flightMode = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RocketMetadata {
    return {
      altArmed: isSet(object.altArmed) ? globalThis.Boolean(object.altArmed) : false,
      altValid: isSet(object.altValid) ? globalThis.Boolean(object.altValid) : false,
      gpsValid: isSet(object.gpsValid) ? globalThis.Boolean(object.gpsValid) : false,
      imuValid: isSet(object.imuValid) ? globalThis.Boolean(object.imuValid) : false,
      accValid: isSet(object.accValid) ? globalThis.Boolean(object.accValid) : false,
      thermValid: isSet(object.thermValid) ? globalThis.Boolean(object.thermValid) : false,
      voltageValid: isSet(object.voltageValid) ? globalThis.Boolean(object.voltageValid) : false,
      adcValid: isSet(object.adcValid) ? globalThis.Boolean(object.adcValid) : false,
      framValid: isSet(object.framValid) ? globalThis.Boolean(object.framValid) : false,
      sdValid: isSet(object.sdValid) ? globalThis.Boolean(object.sdValid) : false,
      gpsMsgValid: isSet(object.gpsMsgValid) ? globalThis.Boolean(object.gpsMsgValid) : false,
      mavState: isSet(object.mavState) ? globalThis.Boolean(object.mavState) : false,
      svState: isSet(object.svState) ? globalThis.Boolean(object.svState) : false,
      flightMode: isSet(object.flightMode) ? flightModeFromJSON(object.flightMode) : 0,
    };
  },

  toJSON(message: RocketMetadata): unknown {
    const obj: any = {};
    if (message.altArmed !== false) {
      obj.altArmed = message.altArmed;
    }
    if (message.altValid !== false) {
      obj.altValid = message.altValid;
    }
    if (message.gpsValid !== false) {
      obj.gpsValid = message.gpsValid;
    }
    if (message.imuValid !== false) {
      obj.imuValid = message.imuValid;
    }
    if (message.accValid !== false) {
      obj.accValid = message.accValid;
    }
    if (message.thermValid !== false) {
      obj.thermValid = message.thermValid;
    }
    if (message.voltageValid !== false) {
      obj.voltageValid = message.voltageValid;
    }
    if (message.adcValid !== false) {
      obj.adcValid = message.adcValid;
    }
    if (message.framValid !== false) {
      obj.framValid = message.framValid;
    }
    if (message.sdValid !== false) {
      obj.sdValid = message.sdValid;
    }
    if (message.gpsMsgValid !== false) {
      obj.gpsMsgValid = message.gpsMsgValid;
    }
    if (message.mavState !== false) {
      obj.mavState = message.mavState;
    }
    if (message.svState !== false) {
      obj.svState = message.svState;
    }
    if (message.flightMode !== 0) {
      obj.flightMode = flightModeToJSON(message.flightMode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RocketMetadata>, I>>(base?: I): RocketMetadata {
    return RocketMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RocketMetadata>, I>>(object: I): RocketMetadata {
    const message = createBaseRocketMetadata();
    message.altArmed = object.altArmed ?? false;
    message.altValid = object.altValid ?? false;
    message.gpsValid = object.gpsValid ?? false;
    message.imuValid = object.imuValid ?? false;
    message.accValid = object.accValid ?? false;
    message.thermValid = object.thermValid ?? false;
    message.voltageValid = object.voltageValid ?? false;
    message.adcValid = object.adcValid ?? false;
    message.framValid = object.framValid ?? false;
    message.sdValid = object.sdValid ?? false;
    message.gpsMsgValid = object.gpsMsgValid ?? false;
    message.mavState = object.mavState ?? false;
    message.svState = object.svState ?? false;
    message.flightMode = object.flightMode ?? 0;
    return message;
  },
};

function createBaseGPSTelemetry(): GPSTelemetry {
  return { latitude: 0, longitude: 0, numSatellites: 0, utcTime: 0 };
}

export const GPSTelemetry: MessageFns<GPSTelemetry> = {
  encode(message: GPSTelemetry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.latitude !== 0) {
      writer.uint32(8).int32(message.latitude);
    }
    if (message.longitude !== 0) {
      writer.uint32(16).int32(message.longitude);
    }
    if (message.numSatellites !== 0) {
      writer.uint32(24).uint32(message.numSatellites);
    }
    if (message.utcTime !== 0) {
      writer.uint32(32).uint32(message.utcTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GPSTelemetry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGPSTelemetry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.latitude = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.longitude = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.numSatellites = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.utcTime = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GPSTelemetry {
    return {
      latitude: isSet(object.latitude) ? globalThis.Number(object.latitude) : 0,
      longitude: isSet(object.longitude) ? globalThis.Number(object.longitude) : 0,
      numSatellites: isSet(object.numSatellites) ? globalThis.Number(object.numSatellites) : 0,
      utcTime: isSet(object.utcTime) ? globalThis.Number(object.utcTime) : 0,
    };
  },

  toJSON(message: GPSTelemetry): unknown {
    const obj: any = {};
    if (message.latitude !== 0) {
      obj.latitude = Math.round(message.latitude);
    }
    if (message.longitude !== 0) {
      obj.longitude = Math.round(message.longitude);
    }
    if (message.numSatellites !== 0) {
      obj.numSatellites = Math.round(message.numSatellites);
    }
    if (message.utcTime !== 0) {
      obj.utcTime = Math.round(message.utcTime);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GPSTelemetry>, I>>(base?: I): GPSTelemetry {
    return GPSTelemetry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GPSTelemetry>, I>>(object: I): GPSTelemetry {
    const message = createBaseGPSTelemetry();
    message.latitude = object.latitude ?? 0;
    message.longitude = object.longitude ?? 0;
    message.numSatellites = object.numSatellites ?? 0;
    message.utcTime = object.utcTime ?? 0;
    return message;
  },
};

function createBaseAccelerometerTelemetry(): AccelerometerTelemetry {
  return { accelX: 0, accelY: 0, accelZ: 0 };
}

export const AccelerometerTelemetry: MessageFns<AccelerometerTelemetry> = {
  encode(message: AccelerometerTelemetry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accelX !== 0) {
      writer.uint32(13).float(message.accelX);
    }
    if (message.accelY !== 0) {
      writer.uint32(21).float(message.accelY);
    }
    if (message.accelZ !== 0) {
      writer.uint32(29).float(message.accelZ);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccelerometerTelemetry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccelerometerTelemetry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.accelX = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.accelY = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.accelZ = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccelerometerTelemetry {
    return {
      accelX: isSet(object.accelX) ? globalThis.Number(object.accelX) : 0,
      accelY: isSet(object.accelY) ? globalThis.Number(object.accelY) : 0,
      accelZ: isSet(object.accelZ) ? globalThis.Number(object.accelZ) : 0,
    };
  },

  toJSON(message: AccelerometerTelemetry): unknown {
    const obj: any = {};
    if (message.accelX !== 0) {
      obj.accelX = message.accelX;
    }
    if (message.accelY !== 0) {
      obj.accelY = message.accelY;
    }
    if (message.accelZ !== 0) {
      obj.accelZ = message.accelZ;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccelerometerTelemetry>, I>>(base?: I): AccelerometerTelemetry {
    return AccelerometerTelemetry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccelerometerTelemetry>, I>>(object: I): AccelerometerTelemetry {
    const message = createBaseAccelerometerTelemetry();
    message.accelX = object.accelX ?? 0;
    message.accelY = object.accelY ?? 0;
    message.accelZ = object.accelZ ?? 0;
    return message;
  },
};

function createBaseIMUTelemetry(): IMUTelemetry {
  return {
    gyroX: 0,
    gyroY: 0,
    gyroZ: 0,
    accelX: 0,
    accelY: 0,
    accelZ: 0,
    oriX: 0,
    oriY: 0,
    oriZ: 0,
    gravX: 0,
    gravY: 0,
    gravZ: 0,
  };
}

export const IMUTelemetry: MessageFns<IMUTelemetry> = {
  encode(message: IMUTelemetry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gyroX !== 0) {
      writer.uint32(13).float(message.gyroX);
    }
    if (message.gyroY !== 0) {
      writer.uint32(21).float(message.gyroY);
    }
    if (message.gyroZ !== 0) {
      writer.uint32(29).float(message.gyroZ);
    }
    if (message.accelX !== 0) {
      writer.uint32(37).float(message.accelX);
    }
    if (message.accelY !== 0) {
      writer.uint32(45).float(message.accelY);
    }
    if (message.accelZ !== 0) {
      writer.uint32(53).float(message.accelZ);
    }
    if (message.oriX !== 0) {
      writer.uint32(61).float(message.oriX);
    }
    if (message.oriY !== 0) {
      writer.uint32(69).float(message.oriY);
    }
    if (message.oriZ !== 0) {
      writer.uint32(77).float(message.oriZ);
    }
    if (message.gravX !== 0) {
      writer.uint32(85).float(message.gravX);
    }
    if (message.gravY !== 0) {
      writer.uint32(93).float(message.gravY);
    }
    if (message.gravZ !== 0) {
      writer.uint32(101).float(message.gravZ);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IMUTelemetry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIMUTelemetry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.gyroX = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.gyroY = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.gyroZ = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.accelX = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.accelY = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.accelZ = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.oriX = reader.float();
          continue;
        }
        case 8: {
          if (tag !== 69) {
            break;
          }

          message.oriY = reader.float();
          continue;
        }
        case 9: {
          if (tag !== 77) {
            break;
          }

          message.oriZ = reader.float();
          continue;
        }
        case 10: {
          if (tag !== 85) {
            break;
          }

          message.gravX = reader.float();
          continue;
        }
        case 11: {
          if (tag !== 93) {
            break;
          }

          message.gravY = reader.float();
          continue;
        }
        case 12: {
          if (tag !== 101) {
            break;
          }

          message.gravZ = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IMUTelemetry {
    return {
      gyroX: isSet(object.gyroX) ? globalThis.Number(object.gyroX) : 0,
      gyroY: isSet(object.gyroY) ? globalThis.Number(object.gyroY) : 0,
      gyroZ: isSet(object.gyroZ) ? globalThis.Number(object.gyroZ) : 0,
      accelX: isSet(object.accelX) ? globalThis.Number(object.accelX) : 0,
      accelY: isSet(object.accelY) ? globalThis.Number(object.accelY) : 0,
      accelZ: isSet(object.accelZ) ? globalThis.Number(object.accelZ) : 0,
      oriX: isSet(object.oriX) ? globalThis.Number(object.oriX) : 0,
      oriY: isSet(object.oriY) ? globalThis.Number(object.oriY) : 0,
      oriZ: isSet(object.oriZ) ? globalThis.Number(object.oriZ) : 0,
      gravX: isSet(object.gravX) ? globalThis.Number(object.gravX) : 0,
      gravY: isSet(object.gravY) ? globalThis.Number(object.gravY) : 0,
      gravZ: isSet(object.gravZ) ? globalThis.Number(object.gravZ) : 0,
    };
  },

  toJSON(message: IMUTelemetry): unknown {
    const obj: any = {};
    if (message.gyroX !== 0) {
      obj.gyroX = message.gyroX;
    }
    if (message.gyroY !== 0) {
      obj.gyroY = message.gyroY;
    }
    if (message.gyroZ !== 0) {
      obj.gyroZ = message.gyroZ;
    }
    if (message.accelX !== 0) {
      obj.accelX = message.accelX;
    }
    if (message.accelY !== 0) {
      obj.accelY = message.accelY;
    }
    if (message.accelZ !== 0) {
      obj.accelZ = message.accelZ;
    }
    if (message.oriX !== 0) {
      obj.oriX = message.oriX;
    }
    if (message.oriY !== 0) {
      obj.oriY = message.oriY;
    }
    if (message.oriZ !== 0) {
      obj.oriZ = message.oriZ;
    }
    if (message.gravX !== 0) {
      obj.gravX = message.gravX;
    }
    if (message.gravY !== 0) {
      obj.gravY = message.gravY;
    }
    if (message.gravZ !== 0) {
      obj.gravZ = message.gravZ;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IMUTelemetry>, I>>(base?: I): IMUTelemetry {
    return IMUTelemetry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IMUTelemetry>, I>>(object: I): IMUTelemetry {
    const message = createBaseIMUTelemetry();
    message.gyroX = object.gyroX ?? 0;
    message.gyroY = object.gyroY ?? 0;
    message.gyroZ = object.gyroZ ?? 0;
    message.accelX = object.accelX ?? 0;
    message.accelY = object.accelY ?? 0;
    message.accelZ = object.accelZ ?? 0;
    message.oriX = object.oriX ?? 0;
    message.oriY = object.oriY ?? 0;
    message.oriZ = object.oriZ ?? 0;
    message.gravX = object.gravX ?? 0;
    message.gravY = object.gravY ?? 0;
    message.gravZ = object.gravZ ?? 0;
    return message;
  },
};

function createBaseRocketLoRaTelemetry(): RocketLoRaTelemetry {
  return {
    metadata: undefined,
    msSinceBoot: 0,
    events: undefined,
    altitude: 0,
    gpsTelem: undefined,
    imuTelem: undefined,
    accelTelem: undefined,
    temp: 0,
    voltage: 0,
    pt3: 0,
    pt4: 0,
    blimsState: 0,
  };
}

export const RocketLoRaTelemetry: MessageFns<RocketLoRaTelemetry> = {
  encode(message: RocketLoRaTelemetry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadata !== undefined) {
      RocketMetadata.encode(message.metadata, writer.uint32(10).fork()).join();
    }
    if (message.msSinceBoot !== 0) {
      writer.uint32(16).uint32(message.msSinceBoot);
    }
    if (message.events !== undefined) {
      Events.encode(message.events, writer.uint32(26).fork()).join();
    }
    if (message.altitude !== 0) {
      writer.uint32(37).float(message.altitude);
    }
    if (message.gpsTelem !== undefined) {
      GPSTelemetry.encode(message.gpsTelem, writer.uint32(42).fork()).join();
    }
    if (message.imuTelem !== undefined) {
      IMUTelemetry.encode(message.imuTelem, writer.uint32(50).fork()).join();
    }
    if (message.accelTelem !== undefined) {
      AccelerometerTelemetry.encode(message.accelTelem, writer.uint32(58).fork()).join();
    }
    if (message.temp !== 0) {
      writer.uint32(69).float(message.temp);
    }
    if (message.voltage !== 0) {
      writer.uint32(77).float(message.voltage);
    }
    if (message.pt3 !== 0) {
      writer.uint32(85).float(message.pt3);
    }
    if (message.pt4 !== 0) {
      writer.uint32(93).float(message.pt4);
    }
    if (message.blimsState !== 0) {
      writer.uint32(101).float(message.blimsState);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RocketLoRaTelemetry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRocketLoRaTelemetry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metadata = RocketMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.msSinceBoot = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.events = Events.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.altitude = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.gpsTelem = GPSTelemetry.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.imuTelem = IMUTelemetry.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.accelTelem = AccelerometerTelemetry.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 69) {
            break;
          }

          message.temp = reader.float();
          continue;
        }
        case 9: {
          if (tag !== 77) {
            break;
          }

          message.voltage = reader.float();
          continue;
        }
        case 10: {
          if (tag !== 85) {
            break;
          }

          message.pt3 = reader.float();
          continue;
        }
        case 11: {
          if (tag !== 93) {
            break;
          }

          message.pt4 = reader.float();
          continue;
        }
        case 12: {
          if (tag !== 101) {
            break;
          }

          message.blimsState = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RocketLoRaTelemetry {
    return {
      metadata: isSet(object.metadata) ? RocketMetadata.fromJSON(object.metadata) : undefined,
      msSinceBoot: isSet(object.msSinceBoot) ? globalThis.Number(object.msSinceBoot) : 0,
      events: isSet(object.events) ? Events.fromJSON(object.events) : undefined,
      altitude: isSet(object.altitude) ? globalThis.Number(object.altitude) : 0,
      gpsTelem: isSet(object.gpsTelem) ? GPSTelemetry.fromJSON(object.gpsTelem) : undefined,
      imuTelem: isSet(object.imuTelem) ? IMUTelemetry.fromJSON(object.imuTelem) : undefined,
      accelTelem: isSet(object.accelTelem) ? AccelerometerTelemetry.fromJSON(object.accelTelem) : undefined,
      temp: isSet(object.temp) ? globalThis.Number(object.temp) : 0,
      voltage: isSet(object.voltage) ? globalThis.Number(object.voltage) : 0,
      pt3: isSet(object.pt3) ? globalThis.Number(object.pt3) : 0,
      pt4: isSet(object.pt4) ? globalThis.Number(object.pt4) : 0,
      blimsState: isSet(object.blimsState) ? globalThis.Number(object.blimsState) : 0,
    };
  },

  toJSON(message: RocketLoRaTelemetry): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = RocketMetadata.toJSON(message.metadata);
    }
    if (message.msSinceBoot !== 0) {
      obj.msSinceBoot = Math.round(message.msSinceBoot);
    }
    if (message.events !== undefined) {
      obj.events = Events.toJSON(message.events);
    }
    if (message.altitude !== 0) {
      obj.altitude = message.altitude;
    }
    if (message.gpsTelem !== undefined) {
      obj.gpsTelem = GPSTelemetry.toJSON(message.gpsTelem);
    }
    if (message.imuTelem !== undefined) {
      obj.imuTelem = IMUTelemetry.toJSON(message.imuTelem);
    }
    if (message.accelTelem !== undefined) {
      obj.accelTelem = AccelerometerTelemetry.toJSON(message.accelTelem);
    }
    if (message.temp !== 0) {
      obj.temp = message.temp;
    }
    if (message.voltage !== 0) {
      obj.voltage = message.voltage;
    }
    if (message.pt3 !== 0) {
      obj.pt3 = message.pt3;
    }
    if (message.pt4 !== 0) {
      obj.pt4 = message.pt4;
    }
    if (message.blimsState !== 0) {
      obj.blimsState = message.blimsState;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RocketLoRaTelemetry>, I>>(base?: I): RocketLoRaTelemetry {
    return RocketLoRaTelemetry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RocketLoRaTelemetry>, I>>(object: I): RocketLoRaTelemetry {
    const message = createBaseRocketLoRaTelemetry();
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? RocketMetadata.fromPartial(object.metadata)
      : undefined;
    message.msSinceBoot = object.msSinceBoot ?? 0;
    message.events = (object.events !== undefined && object.events !== null)
      ? Events.fromPartial(object.events)
      : undefined;
    message.altitude = object.altitude ?? 0;
    message.gpsTelem = (object.gpsTelem !== undefined && object.gpsTelem !== null)
      ? GPSTelemetry.fromPartial(object.gpsTelem)
      : undefined;
    message.imuTelem = (object.imuTelem !== undefined && object.imuTelem !== null)
      ? IMUTelemetry.fromPartial(object.imuTelem)
      : undefined;
    message.accelTelem = (object.accelTelem !== undefined && object.accelTelem !== null)
      ? AccelerometerTelemetry.fromPartial(object.accelTelem)
      : undefined;
    message.temp = object.temp ?? 0;
    message.voltage = object.voltage ?? 0;
    message.pt3 = object.pt3 ?? 0;
    message.pt4 = object.pt4 ?? 0;
    message.blimsState = object.blimsState ?? 0;
    return message;
  },
};

function createBaseRocketUmbTelemetry(): RocketUmbTelemetry {
  return {
    metadata: undefined,
    msSinceBoot: 0,
    events: undefined,
    radioState: false,
    transmitState: false,
    voltage: 0,
    pt3: 0,
    pt4: 0,
    rtdTemp: 0,
  };
}

export const RocketUmbTelemetry: MessageFns<RocketUmbTelemetry> = {
  encode(message: RocketUmbTelemetry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadata !== undefined) {
      RocketMetadata.encode(message.metadata, writer.uint32(10).fork()).join();
    }
    if (message.msSinceBoot !== 0) {
      writer.uint32(16).uint32(message.msSinceBoot);
    }
    if (message.events !== undefined) {
      Events.encode(message.events, writer.uint32(26).fork()).join();
    }
    if (message.radioState !== false) {
      writer.uint32(32).bool(message.radioState);
    }
    if (message.transmitState !== false) {
      writer.uint32(40).bool(message.transmitState);
    }
    if (message.voltage !== 0) {
      writer.uint32(53).float(message.voltage);
    }
    if (message.pt3 !== 0) {
      writer.uint32(61).float(message.pt3);
    }
    if (message.pt4 !== 0) {
      writer.uint32(69).float(message.pt4);
    }
    if (message.rtdTemp !== 0) {
      writer.uint32(77).float(message.rtdTemp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RocketUmbTelemetry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRocketUmbTelemetry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metadata = RocketMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.msSinceBoot = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.events = Events.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.radioState = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.transmitState = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.voltage = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.pt3 = reader.float();
          continue;
        }
        case 8: {
          if (tag !== 69) {
            break;
          }

          message.pt4 = reader.float();
          continue;
        }
        case 9: {
          if (tag !== 77) {
            break;
          }

          message.rtdTemp = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RocketUmbTelemetry {
    return {
      metadata: isSet(object.metadata) ? RocketMetadata.fromJSON(object.metadata) : undefined,
      msSinceBoot: isSet(object.msSinceBoot) ? globalThis.Number(object.msSinceBoot) : 0,
      events: isSet(object.events) ? Events.fromJSON(object.events) : undefined,
      radioState: isSet(object.radioState) ? globalThis.Boolean(object.radioState) : false,
      transmitState: isSet(object.transmitState) ? globalThis.Boolean(object.transmitState) : false,
      voltage: isSet(object.voltage) ? globalThis.Number(object.voltage) : 0,
      pt3: isSet(object.pt3) ? globalThis.Number(object.pt3) : 0,
      pt4: isSet(object.pt4) ? globalThis.Number(object.pt4) : 0,
      rtdTemp: isSet(object.rtdTemp) ? globalThis.Number(object.rtdTemp) : 0,
    };
  },

  toJSON(message: RocketUmbTelemetry): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = RocketMetadata.toJSON(message.metadata);
    }
    if (message.msSinceBoot !== 0) {
      obj.msSinceBoot = Math.round(message.msSinceBoot);
    }
    if (message.events !== undefined) {
      obj.events = Events.toJSON(message.events);
    }
    if (message.radioState !== false) {
      obj.radioState = message.radioState;
    }
    if (message.transmitState !== false) {
      obj.transmitState = message.transmitState;
    }
    if (message.voltage !== 0) {
      obj.voltage = message.voltage;
    }
    if (message.pt3 !== 0) {
      obj.pt3 = message.pt3;
    }
    if (message.pt4 !== 0) {
      obj.pt4 = message.pt4;
    }
    if (message.rtdTemp !== 0) {
      obj.rtdTemp = message.rtdTemp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RocketUmbTelemetry>, I>>(base?: I): RocketUmbTelemetry {
    return RocketUmbTelemetry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RocketUmbTelemetry>, I>>(object: I): RocketUmbTelemetry {
    const message = createBaseRocketUmbTelemetry();
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? RocketMetadata.fromPartial(object.metadata)
      : undefined;
    message.msSinceBoot = object.msSinceBoot ?? 0;
    message.events = (object.events !== undefined && object.events !== null)
      ? Events.fromPartial(object.events)
      : undefined;
    message.radioState = object.radioState ?? false;
    message.transmitState = object.transmitState ?? false;
    message.voltage = object.voltage ?? 0;
    message.pt3 = object.pt3 ?? 0;
    message.pt4 = object.pt4 ?? 0;
    message.rtdTemp = object.rtdTemp ?? 0;
    return message;
  },
};

function createBaseRocketTelemetry(): RocketTelemetry {
  return { loraTelem: undefined, umbTelem: undefined };
}

export const RocketTelemetry: MessageFns<RocketTelemetry> = {
  encode(message: RocketTelemetry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.loraTelem !== undefined) {
      RocketLoRaTelemetry.encode(message.loraTelem, writer.uint32(10).fork()).join();
    }
    if (message.umbTelem !== undefined) {
      RocketUmbTelemetry.encode(message.umbTelem, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RocketTelemetry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRocketTelemetry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.loraTelem = RocketLoRaTelemetry.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.umbTelem = RocketUmbTelemetry.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RocketTelemetry {
    return {
      loraTelem: isSet(object.loraTelem) ? RocketLoRaTelemetry.fromJSON(object.loraTelem) : undefined,
      umbTelem: isSet(object.umbTelem) ? RocketUmbTelemetry.fromJSON(object.umbTelem) : undefined,
    };
  },

  toJSON(message: RocketTelemetry): unknown {
    const obj: any = {};
    if (message.loraTelem !== undefined) {
      obj.loraTelem = RocketLoRaTelemetry.toJSON(message.loraTelem);
    }
    if (message.umbTelem !== undefined) {
      obj.umbTelem = RocketUmbTelemetry.toJSON(message.umbTelem);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RocketTelemetry>, I>>(base?: I): RocketTelemetry {
    return RocketTelemetry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RocketTelemetry>, I>>(object: I): RocketTelemetry {
    const message = createBaseRocketTelemetry();
    message.loraTelem = (object.loraTelem !== undefined && object.loraTelem !== null)
      ? RocketLoRaTelemetry.fromPartial(object.loraTelem)
      : undefined;
    message.umbTelem = (object.umbTelem !== undefined && object.umbTelem !== null)
      ? RocketUmbTelemetry.fromPartial(object.umbTelem)
      : undefined;
    return message;
  },
};

function createBaseFillStationTelemetry(): FillStationTelemetry {
  return { timestamp: 0, pt1: 0, pt2: 0, lc1: 0, sv1Cont: 0, ign1Cont: 0, ign2Cont: 0 };
}

export const FillStationTelemetry: MessageFns<FillStationTelemetry> = {
  encode(message: FillStationTelemetry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== 0) {
      writer.uint32(8).uint32(message.timestamp);
    }
    if (message.pt1 !== 0) {
      writer.uint32(21).float(message.pt1);
    }
    if (message.pt2 !== 0) {
      writer.uint32(29).float(message.pt2);
    }
    if (message.lc1 !== 0) {
      writer.uint32(37).float(message.lc1);
    }
    if (message.sv1Cont !== 0) {
      writer.uint32(45).float(message.sv1Cont);
    }
    if (message.ign1Cont !== 0) {
      writer.uint32(53).float(message.ign1Cont);
    }
    if (message.ign2Cont !== 0) {
      writer.uint32(61).float(message.ign2Cont);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FillStationTelemetry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFillStationTelemetry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.timestamp = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.pt1 = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.pt2 = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.lc1 = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.sv1Cont = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.ign1Cont = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.ign2Cont = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FillStationTelemetry {
    return {
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      pt1: isSet(object.pt1) ? globalThis.Number(object.pt1) : 0,
      pt2: isSet(object.pt2) ? globalThis.Number(object.pt2) : 0,
      lc1: isSet(object.lc1) ? globalThis.Number(object.lc1) : 0,
      sv1Cont: isSet(object.sv1Cont) ? globalThis.Number(object.sv1Cont) : 0,
      ign1Cont: isSet(object.ign1Cont) ? globalThis.Number(object.ign1Cont) : 0,
      ign2Cont: isSet(object.ign2Cont) ? globalThis.Number(object.ign2Cont) : 0,
    };
  },

  toJSON(message: FillStationTelemetry): unknown {
    const obj: any = {};
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.pt1 !== 0) {
      obj.pt1 = message.pt1;
    }
    if (message.pt2 !== 0) {
      obj.pt2 = message.pt2;
    }
    if (message.lc1 !== 0) {
      obj.lc1 = message.lc1;
    }
    if (message.sv1Cont !== 0) {
      obj.sv1Cont = message.sv1Cont;
    }
    if (message.ign1Cont !== 0) {
      obj.ign1Cont = message.ign1Cont;
    }
    if (message.ign2Cont !== 0) {
      obj.ign2Cont = message.ign2Cont;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FillStationTelemetry>, I>>(base?: I): FillStationTelemetry {
    return FillStationTelemetry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FillStationTelemetry>, I>>(object: I): FillStationTelemetry {
    const message = createBaseFillStationTelemetry();
    message.timestamp = object.timestamp ?? 0;
    message.pt1 = object.pt1 ?? 0;
    message.pt2 = object.pt2 ?? 0;
    message.lc1 = object.lc1 ?? 0;
    message.sv1Cont = object.sv1Cont ?? 0;
    message.ign1Cont = object.ign1Cont ?? 0;
    message.ign2Cont = object.ign2Cont ?? 0;
    return message;
  },
};

/** The telemetry service definition */
export type FillStationTelemeterService = typeof FillStationTelemeterService;
export const FillStationTelemeterService = {
  /** Sends telemetry */
  streamTelemetry: {
    path: "/command.FillStationTelemeter/StreamTelemetry",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: TelemetryRequest) => Buffer.from(TelemetryRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TelemetryRequest.decode(value),
    responseSerialize: (value: FillStationTelemetry) => Buffer.from(FillStationTelemetry.encode(value).finish()),
    responseDeserialize: (value: Buffer) => FillStationTelemetry.decode(value),
  },
} as const;

export interface FillStationTelemeterServer extends UntypedServiceImplementation {
  /** Sends telemetry */
  streamTelemetry: handleServerStreamingCall<TelemetryRequest, FillStationTelemetry>;
}

export interface FillStationTelemeterClient extends Client {
  /** Sends telemetry */
  streamTelemetry(
    request: TelemetryRequest,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<FillStationTelemetry>;
  streamTelemetry(
    request: TelemetryRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<FillStationTelemetry>;
}

export const FillStationTelemeterClient = makeGenericClientConstructor(
  FillStationTelemeterService,
  "command.FillStationTelemeter",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): FillStationTelemeterClient;
  service: typeof FillStationTelemeterService;
  serviceName: string;
};

/** The telemetry service definition */
export type RocketTelemeterService = typeof RocketTelemeterService;
export const RocketTelemeterService = {
  /** Sends telemetry */
  streamTelemetry: {
    path: "/command.RocketTelemeter/StreamTelemetry",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: TelemetryRequest) => Buffer.from(TelemetryRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TelemetryRequest.decode(value),
    responseSerialize: (value: RocketTelemetry) => Buffer.from(RocketTelemetry.encode(value).finish()),
    responseDeserialize: (value: Buffer) => RocketTelemetry.decode(value),
  },
} as const;

export interface RocketTelemeterServer extends UntypedServiceImplementation {
  /** Sends telemetry */
  streamTelemetry: handleServerStreamingCall<TelemetryRequest, RocketTelemetry>;
}

export interface RocketTelemeterClient extends Client {
  /** Sends telemetry */
  streamTelemetry(request: TelemetryRequest, options?: Partial<CallOptions>): ClientReadableStream<RocketTelemetry>;
  streamTelemetry(
    request: TelemetryRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<RocketTelemetry>;
}

export const RocketTelemeterClient = makeGenericClientConstructor(
  RocketTelemeterService,
  "command.RocketTelemeter",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): RocketTelemeterClient;
  service: typeof RocketTelemeterService;
  serviceName: string;
};

/** The commanding service definition */
export type CommanderService = typeof CommanderService;
export const CommanderService = {
  /** Sends telemetry */
  sendCommand: {
    path: "/command.Commander/SendCommand",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Command) => Buffer.from(Command.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Command.decode(value),
    responseSerialize: (value: CommandReply) => Buffer.from(CommandReply.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CommandReply.decode(value),
  },
} as const;

export interface CommanderServer extends UntypedServiceImplementation {
  /** Sends telemetry */
  sendCommand: handleUnaryCall<Command, CommandReply>;
}

export interface CommanderClient extends Client {
  /** Sends telemetry */
  sendCommand(
    request: Command,
    callback: (error: ServiceError | null, response: CommandReply) => void,
  ): ClientUnaryCall;
  sendCommand(
    request: Command,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CommandReply) => void,
  ): ClientUnaryCall;
  sendCommand(
    request: Command,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CommandReply) => void,
  ): ClientUnaryCall;
}

export const CommanderClient = makeGenericClientConstructor(CommanderService, "command.Commander") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): CommanderClient;
  service: typeof CommanderService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
